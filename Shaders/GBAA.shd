
struct PsIn
{
	float4 Position : SV_Position;
	float2 TexCoord : TexCoord;
};

[Vertex shader]

PsIn main(uint VertexID : SV_VertexID)
{
	// Produce a fullscreen triangle
	PsIn Out;
	Out.Position.x = (VertexID == 0)? 3.0f : -1.0f;
	Out.Position.y = (VertexID == 2)? 3.0f : -1.0f;
	Out.Position.zw = 1.0f;
	Out.TexCoord = Out.Position.xy * float2(0.5f, -0.5f) + 0.5f;

	return Out;
}

[Fragment shader]

Texture2D BackBuffer;
Texture2D <float2> GeometryBuffer;
SamplerState Linear;
SamplerState Point;

float2 PixelSize;
int Tweak;
int ShowEdges;

bool check_opposite_neighbor(float2 tex_coord, float2 offset)
{
    // 1] select major offset
    float2 off;
    bool x_major = abs(offset.x) < abs(offset.y);
    if (x_major)
        off = float2(sign(offset.x), 0);
    else
        off = float2(0, sign(offset.y));
    // 2] select neighbor's offset
    float2 opp_offset = GeometryBuffer.Sample(Point, tex_coord + off*PixelSize);
    // 3] make sure it is valid
    bool apply_offset = true;
    if (min(abs(opp_offset.x), abs(opp_offset.y)) < 0.5f)
    {
        // 4] make sure it points towards current sample
        // if so - don't apply texture coordinate offset
        if (x_major)
            apply_offset = !(sign(offset.x)!=sign(opp_offset.x) && abs(offset.x-opp_offset.x) < 1.0f);
        else
            apply_offset = !(sign(offset.y)!=sign(opp_offset.y) && abs(offset.y-opp_offset.y) < 1.0f);
    }
    return apply_offset;
}

float4 main(PsIn In) : SV_Target
{
    bool apply_offset = true;
	float2 offset = GeometryBuffer.Sample(Point, In.TexCoord);
    bool edge_found = false;
	// Check geometry buffer for an edge cutting through the pixel.
	[flatten]
	if (min(abs(offset.x), abs(offset.y)) >= 0.5f)
	{
		// If no edge was found we look in neighboring pixels' geometry information. This is necessary because
		// relevant geometry information may only be available on one side of an edge, such as on silhouette edges,
		// where a background pixel adjacent to the edge will have the background's geometry information, and not
		// the foreground's geometric edge that we need to antialias against. Doing this step covers up gaps in the
		// geometry information.

		offset = 0.5f;

		// We only need to check the component on neighbor samples that point towards us
		float offset_x0 = GeometryBuffer.Sample(Point, In.TexCoord, int2(-1,  0)).x;
		float offset_x1 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 1,  0)).x;
		float offset_y0 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 0, -1)).y;
		float offset_y1 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 0,  1)).y;

		// Check range of neighbor pixels' distance and use if edge cuts this pixel.
		if (abs(offset_x0 - 0.75f) < 0.25f)
        {
            edge_found = true;
            offset = float2(offset_x0 - 1.0f, 0.5f); // Left  x-offset [ 0.5 ..  1.0] cuts this pixel
        }
		if (abs(offset_x1 + 0.75f) < 0.25f)
        {
            edge_found = true;
            offset = float2(offset_x1 + 1.0f, 0.5f); // Right x-offset [-1.0 .. -0.5] cuts this pixel
        }
		if (abs(offset_y0 - 0.75f) < 0.25f)
        {
            edge_found = true;
            offset = float2(0.5f, offset_y0 - 1.0f); // Up    y-offset [ 0.5 ..  1.0] cuts this pixel
        }
		if (abs(offset_y1 + 0.75f) < 0.25f)
        {
            edge_found = true;
            offset = float2(0.5f, offset_y1 + 1.0f); // Down  y-offset [-1.0 .. -0.5] cuts this pixel
        }
	}
    else
    {
        edge_found = true;
        if (Tweak)
            apply_offset = check_opposite_neighbor(In.TexCoord, offset);
    }

	// Convert distance to texture coordinate shift
	float2 off = (offset >= float2(0, 0))? float2(0.5f, 0.5f) : float2(-0.5f, -0.5f);
	offset = off - offset;

	// Blend pixel with neighbor pixel using texture filtering and shifting the coordinate appropriately.
    if (ShowEdges && edge_found)
        return float4(1, 0, 0, 1);
	else
        return BackBuffer.Sample(Linear, In.TexCoord + (apply_offset ? offset * PixelSize : float2(0, 0)));
}
